# C++ Primer Plus 学习笔记

by cqqqwq

Thinking in C++ 这本书实在讲的太墨迹了。

[TOC]

## 第九章 内存模型与名称空间

### 如何组织一个程序的文件？

1. 头文件`xxx.h`：包括结构/类的声明（结构的所有成员），使用这些结构/类的函数的声明（不要放函数的定义和变量的定义/声明）
2. 源代码文件A`xxx.cpp` ：包含以上声明函数的具体定义
3. 源代码文件B`main.cpp`：包含调用以上函数的代码

### 使用 `#include` 

+ `#include<...>` 从系统 path 开始查找。
+ `#include"..."` 从当前路径开始查找，找不到再去系统 path 查找。

#### 避免多次 `include`

```cpp
#ifndef XXX_H_
#define XXX_H_
//...
#endif
```

### 链接（`linkage`）

把生成的 `.o` 文件（叫什么？）和库之类的拼到一起，输出可执行文件的过程。

注意：不在同一编译器下生成的多个库可能没有办法统一链接。

哪些东西可以跨文件使用？这牵涉到程序内存分配的问题。

#### 作用域（`scope`）

名称在多大范围是可见的，本质上也就是描述该名称所占用的内存在多大范围上是可见的。

主要作用是考察名称在链接的时候如何可见。

#### 某名称放在某个函数里面的时候...：自动存储的连续性

只有 `{...}` 之间能看到；如果出现了重复名称，内层 `{...}` 的名称会占据优势，但是外层的名称在离开内层之后依旧可用。

## 第十三~十四章 类与继承

### 类（`class`）

类就是用户自定义的类型（`user-defined type`）。`class`，`struct`，`union` 都是类关键字（`class-key`）

声明一个类的方式：`class-key class-head-name;` 

定义一个类的方式：

`class-key [attr] class-head-name [:base-specifier-list] {member-specification};`

类的现实意义，就是建立起了“普遍-个别”的联系，让程序可以表达这样的联系。为了表达普遍性质的联系，需要类的派生与继承。

#### 类的“成员组成”

可以有成员数据（`data member`），成员函数（`member functions`），两者都可以有静态（`static`）与非静态（`non-static`）。

还可以有内含的类型（`nested types`）。如类（`class`）或者枚举体（`enum`）。可以用 `auto` 规避掉私有名称（`private name`）的使用。如 `typedef` 或 `using` 的类型别名。

类的成员声明必须在类的定义中进行。不能补充声明。

类的成员可以具有三种属性：公共（`public`），保护（`protected`），私有（`private`）。公共成员可以任意访问，私有和保护成员则只能被类的成员使用。保护成员在派生类时有不同于私有成员的表现。

有一些特殊的成员函数：缺省/拷贝/移动构造函数（`default/copy/move constructor`），`=` 运算符（拷贝/移动），析构函数（`destructor`）。

类如果有任何一个虚函数（`virtual`），那么这个类的成员将表现出多态性（`polymorphic`）。

### 派生类 （`derived classes`）

派生类阐述的是“是个（`is-a`）”关系。

与派生类相对的概念是基类（`base class`）。

基类和派生类之间的关系用"继承"来描述。

#### 访问许可（`access permission`）与继承（`inheritance`）

根据基类的成员在派生类中被访问的许可，继承分为公有继承和私有继承（和保护继承）。

| 基类中的访问限定<br />在派生类中的地位 | 公有     | 保护     | 私有       | 隐式 `upcasting` |
| -------------------------------------- | -------- | -------- | ---------- | ---------------- |
| 公有继承                               | 公开成员 | 保护成员 | 不可被访问 | 可以             |
| 保护继承                               | 保护成员 | 保护成员 | 不可被访问 | 只能在派生类中   |
| 私有继承                               | 私有成员 | 私有成员 | 不可被访问 | 不可以。         |

所有访问限定都可以通过友元进行忽略。在派生类的成员声明中，可 `using` 基类的某些函数改变其访问属性。【语法： `using <base_class_name>::<member_name>;`】

私有继承的使用情况：`has-a`关系；且派生类需要访问基类的保护成员，或需要重新定义某些函数（只能是虚函数）

#### 派生类对基类的重载（`overload/override`）

派生类中可以对基类的成员（数据？函数？）进行重载。

可以用 指向基类对象的指针/引用 指向 某派生类对象（这称为`upcasting`）。一个特殊情况是对 `*this` 强制做引用转换。

注意私有继承无法完成隐式的 `upcasting` 。

当通过该指针/引用使用成员函数时，默认使用基类版本（除了下文所提到的多态性可以使行为与派生类相同）。【这是静态绑定的要求】

基类的某些函数不会被直接继承。包括：构造函数（自行使用`:` 调用），析构函数（先派生类，再基类），赋值运算符（`=`）。

派生类如果使用了 new ，则必须提供显式赋值运算符。

#### 多态性（`polymorphism`）

多态性指的就是：相同类型的指针/引用可以表现出不同的类型的行为。这些不同的类型应该有派生的相关关系。

采用 `virtual` 关键字声明函数，该函数成为虚函数。虚函数继承后仍有虚属性，即使不显式声明。

通过任何基类的指针/引用 对派生类对象具有虚属性的函数的调用，都会调用在继承树（？多重继承）上距离该对象“本来”的类型最近的版本。

注意：类的析构函数需要声明为虚，从而保证在任何条件下都调用的是派生类的析构函数。

#### 抽象基类（`abstract base classes`）

当对成员函数的声明中存在形如 `virtual <type_name> <function_name>(<args_list>) = 0` 的完全虚函数声明时，该类成为抽象类。

抽象类的基函数成员可以不提供具体的定义（当然也可以提供）。

抽象类不允许被实例化为具体的对象。

### 多重继承（`multiple inheritance`）与虚继承（`virtual inheritance`）

多重继承说的并不是层次上的“多重”，而是直接从“多个”基类继承。使用多重继承时，每个基类都需要给定访问限定符（`public,protected,private`）。

类似访问限定可以使用`virtual` 将继承行为声明为“虚”的，称为虚继承。如果派生类对某基类进行了虚继承，就是声明了该基类“对象”可以被共享，当更高层级的派生类的多重继承产生了对该基类的对象的多次覆盖。


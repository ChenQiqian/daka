# CS:APP 学习笔记

by cqqqwq

好书，好书

[TOC]

## 2 信息的表示与处理

### 2.1.9 移位运算

C 语言中，左/右移 $k$ 位本质上是左/右移 $k \bmod w$ （$w$ 为数的二进制位数）位。

### 2.2.3 补码编码

$-x_{w-1}2^{w-1} + \sum\limits_{i=0}^{w-2}x_i2^i$

表示范围：$-2^{w-1} \rarr 2^{w-1}-1$

#### 旁注：关于printf打印定长整数

使用宏定义：32位有符号用`PRId32` ，64位无符号用 `PRIu64` ；会展开成对劲的样子。

### 2.2.5 C语言中的有符号数和无符号数

$-2147483648$？不靠谱。$-2147483647-1$？ 更靠谱一点。

### 2.2.6 扩展数字的位表示

补码：最高位复制。如 $10001001 = -109 = 1111111110001001$

### 2.3.2 补码加法

补码加法和无符号加法具有完全相同的位级表示

### 2.3.3 补码的非

`-x = ~x+1`

### 2.3.5 补码乘法

补码乘法和无符号乘法具有完全相同的位级表示

用移位和加法来实现。

### 2.3.7 除以2的幂

补码除法用“算术移位”（补充为 $x^{w-1}$） 

### 2.4.1 二进制小数

$b = \sum\limits_{i=\color\red{-n}}^{m}2^i \times b_i$  无法精确表示 1/3 之类的小数

### 2.4.2 IEEE浮点表示

定义一个小数为 $V = (-1)^s \times M \times 2^E$

组成（从高位到低位）：

1. 符号位（ $1$ 位） ：$s = 0$ 是正，$s=1$ 是负
2. 阶码字段（ $k$ 位）：二进制整数 $e$ ，从 $0$ 到 $2^k-1$ 。给定偏移量： $\text{bias} = 2^{k-1} -1$ 。
3. 小数字段（ $n$ 位）：二进制小数 $0 \leq m \leq 1 - \varepsilon,\varepsilon = 2^{-n}$ 。或者可以当成整数再移位也未尝不可。

类型：

1. 非规格化的：$e = 0$ 。令 $E = 1 - \text{bias}, M = m$ 。
2. 规格化的：$1 \leq e \color\red{<} 2^k-1$ 。令 $E = e - \text{bias},M = 1+m$ 。

3. 无穷大： $e = 2^k-1, m = 0$ 。NaN：$e = 2^k-1,m \neq 0$ 。

一些说明：

1. 非规格化中 $E$ 的设置可以提供较为平缓的向规格化的过渡。
2. 规格化数中 $M$ 的设置提供了一位额外的精度，相当于省略掉了最开始的 $1$ 。
3. 如此设置，浮点数的序和直接当作“整数”的序是相同的。并且 $0$ 也是相同的。
4. 单精度：$1+8+23$ 位；双精度： $1+11+52$ 位。

### 2.4.5 浮点运算

不具有结合律，缺少了很重要的一个群属性。

## 3 程序的机器级表示

本章提供了许多示例和大量的练习，来说明汇编语言和编译器的各个不同方面。精通细节是理解更深和更基本概念的先决条件。有人说：“我理解了一般规则，不愿意劳神去学习细节！”他们实际上是在自欺欺人。花时间研究这些示例，完成练习并对照提供的答案来检查你的答案，是非常关键的。

### 3.2.1 机器级代码

ISA：指令集体系结构，将程序的行为描述成好像每条指令都是按顺序进行的，一条指令结束后，另一条指令才开始。

虚拟内存/虚拟地址：用起来像是一个很大的字节数组，实际上是把多个硬件存储器和操作系统软件组合起来。

汇编代码就是二进制机器代码的文字表示。

x86-64 系统：

1. 程序计数器（PC），`%rip` ，**下一条**指令在内存中的地址。
2. 整数寄存器，16个64位整数。
3. 条件码寄存器，存储了最近的算术/逻辑运算的一些状态，用于（数据流中的）条件变化
4. 向量寄存器，存放一个或多个整数或浮点数值。

### 3.3 数据格式

| 数据类型 | 汇编代码后缀 | 大小（字节） |
| -------- | ------------ | ------------ |
| 字节     | b            | 1            |
| 词       | w            | 2            |
| 双词     | l            | 4            |
| 四词     | q            | 8            |
| 单精度   | s            | 4            |
| 双精度   | l            | 8            |

### 3.4.0 寄存器

### 3.4.1 操作数指示符号

一些格式来表示想要的数字。（$\text{Imm}$ 是立即数字）

| 格式       | 实际值                   | 名称 |
| ---------- | ------------------------ | ---- |
| `$Imm`     | $\text{Imm}$             |      |
| $r_a$      | $R[r_a]$                 |      |
| (...)      | M[...]                   |      |
| (,$r_i$,s) | M[...+ $R[r_i] \cdot s$] |      |
| Imm(...)   | M[Imm + ...]             |      |

add from 循环：`标签(%rip)` 会在汇编的时候算出来标签距离。

### 3.4.2 数据传送指令

注意，32位指令会把寄存器高32位搞成 0 （作为目的时）

`MOV S D`：同长度的普通传送

`MOVZ S R` ：S 做 0 扩展后传输到 R

`MOVI S R` ：S 做补码扩展后传输到 R 

不能是两个内存地址。

### 3.4.4 压入和弹出栈数据

`pushq S` `popq D`

会自动更改表示栈顶的指针 `%rsp` ，加 8 或者减 8。

### 3.5 算数和逻辑操作

#### 3.5.1加载有效地址

load effective address (q)

`leaq S D` ： “加载有效地址”，等效于 `D = &S` 。用来产生指针或利用寻址来简单算数。D 只能是寄存器。

也就是把这个地址位置算出来，写进去。

#### 3.5.2 一元和二元操作

`INC/DEC/NEG/NOT D`：一元运算符，分别是自加/自减/取负/取补。

`ADD/SUB/IMUL/XOR/OR/AND S D` ：二元运算符，分别是加/减/乘/异或/或/与。

### 3.5.3 移位操作

`SAL/SHL/SAR/AHR k D` ：二元运算符，分别是左移/左移/算术右移（填上符号位置）/逻辑右移。

会从单字节寄存器 `%cl` 中读取，或者给定立即数。

#### 3.5.5 特殊的算术操作

128 位的有限支持。

`imulq/mulq S`： `R[%rdx]:R[%rax] <-- S * R[%rax]` 有符号以及无符号的全乘法。

`idivq/divq S`： `R[%rdx] <-- R[%rdx]:R[%rax] mod S; R[%rax] <-- R[%rdx]:R[%rax] / S` 有符号以及无符号的除法。

`cqto` ：`R[%rdx]:R[%rax] <-- R[%rax]` （符合补码标准地？）进行符号拓展。

### 3.6.1 条件码寄存器

一些由CPU自动维护的 一个二进制位 的条件码（condition code）寄存器。常见的有：

`CF` 进位标志：最近的操作使得最高位产生了进位。（无符号溢出）

`ZF` 零标志：最近的造作得出的结果为 0。

`SF` 符号标志 ：最近的操作得到的结果为负数。

`OF` 溢出标志：最近的操作导致一个补码溢出（正or负数）

结合算术运算，控制操作可以根据条件码进行条件跳转。

除了 `leaq` 操作外的所有算术和逻辑运算，都会根据具体操作情况修改条件码寄存器。

有专门用来比较&设置条件码的运算，不产生附带的效果，包括：

`CMP S1 S2` ：基于 `S2-S1` 来设置条件码

`TEST S1 S2` ：基于 `S2 & S1` 来设置条件码

### 3.6.2 访问条件码（到其他寄存器&内存）

在使用比较命令（`cmp`）之后（？）

我们不直接访问条件码，而使用 `set` 系列命令把其加载到寄存器/内存中。

包括：

`sete/setz D === D<-ZF`
太多了...感受一下就行了。

相等/0 & 不等/非0
负数 & 非负数
有符号的比较
无符号的比较

### 3.6.5 条件分支的实现——采用跳转指令 

跳转指令分为无条件跳转和有条件跳转。

`jmp label` `jmp *Operand`（例：`jmp *%rax // jmp *(%rax)`）

有条件跳转和 `set` 指令差不多，也是根据条件码跳转。

具体实现上，一般都是PC（程序计数器，`%rip`）相对寻址，只记录一个相对的地址来节省空间和方便链接。

用 goto 替换 if else 来实现条件跳转。

```c
if(test-expr)
  then-statement
else
  else-statement
```

类似伪代码的等价形式：

```c
t = test-expr
if(!t)
  goto .false
then-statement
goto .done
.false:
  else-statement
.done:
```

### 3.6.6 条件分支的实现——采用条件传送

用处：减少流水线预测错误的惩罚。大概有20个时钟周期。

`CMOV S R` 系列指令，目标只能是寄存器，如 `cmove, cmovne, cmovs, cmovns` 之类。

读取 `S` 处的数据，但只有条件码满足指定的条件的时候才会执行移动指令。

有各种长度的版本，可以从 `R` 的描述方法进行推断。

如 `v = test-expr? then-expr: else-expr` 将被化为：

```c
v = then-expr;
ve = else-expr;
t = test-expr;
if(!t) v = ve;
```

可能会出问题，包括计算合法性之类，因此 gcc 通常不采用这种方法编译。

### 3.6.7 循环

`do while`循环：

```c
do{
  body-statement;
} while(test-expr);
```

转化为

```c
loop:
	body-statement;
  t = test-expr;
	if(t)
    goto loop;
```

`while` 循环：

```c
while(test-expr){
  body-statement;
}
```

转化为：

1. jump to middle：先跳到后面做一次检查，再跳回来执行类似 do while 的循环

```c
	goto test;
loop:
	body-statement;
test:
	t = test-expr;
	if(t)
  	goto loop;
```

2. guarded-do：条件成立变成do while，否则不执行了。

```c
t = test-expr
if(!t)
  goto done;
loop:
  body-statment;
	t = test-expr;
	if(t)
    goto loop;
done:
```

`for` 循环：

```c
for(init-expr;test-expr;update-expr){

}
```

有一种等价模式：

```c
init-expr；
while(test-expr){
  body-statement;
	update-expr;
}
```

然而，需要对 `continue` 做出特判，这在循环中不完全等价。

### 3.6.8 switch 语句

gcc根据 switch 情况的数量和 switch 情况的值的密集程度来选择翻译方式。

核心代码：

`jmp *.L4(,%rsi,8)` 寻址，间接跳转。

### 3.7 过程

一种很重要的抽象，提供了一种封装代码的方式。

假设过程 P 调用过程Q，Q执行完成后返回到P。

1. 传递控制：简而言之，程序计数器要能够被适当的设置。
2. 传递数据：简而言之，如何传参，如何返回。
3. 分配和释放内存：简而言之，就是要给局部变量开出空间，收回空间。

### 3.7.1 运行时栈

`%rsp` 指向栈顶的元素。栈空间向小地址增长。

过程需要的存储空间从超出寄存器能够存放的大小（六个整数），就会在栈上来分配空间存储剩下的部分。称作**栈帧**（`stack frame`）。

栈帧的组成：

P 的：Q所需要的第7-n个参数，返回地址，也就是返回的时候从哪个地方继续执行。

Q 的：被保存的寄存器，局部变量，以及被 Q 调用的过程的参数。

### 3.7.2 转移控制

`CALL` 指令：

`call(q)  Label/*Operand` 和 `jmp` 类似。`CALL` 指令会把 Q 返回后 P 的下一条指令的地址压入栈中，然后把 PC（`%rip`）设置成 Q 的起始地址。

`RET` 指令：

`ret(q)` 。 会从栈里弹出来地址，然后放到 PC(`%rip`) 中。
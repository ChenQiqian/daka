# C++ Primer Plus 学习笔记

by cqqqwq

Thinking in C++ 这本书实在讲的太墨迹了。

[TOC]

## 第九章 内存模型与名称空间

### 如何组织一个程序的文件？

1. 头文件`xxx.h`：包括结构/类的声明（结构的所有成员），使用这些结构/类的函数的声明（不要放函数的定义和变量的定义/声明）
2. 源代码文件A`xxx.cpp` ：包含以上声明函数的具体定义
3. 源代码文件B`main.cpp`：包含调用以上函数的代码

### 使用 `#include` 

+ `#include<...>` 从系统 path 开始查找。
+ `#include"..."` 从当前路径开始查找，找不到再去系统 path 查找。

#### 避免多次 `include`

```cpp
#ifndef XXX_H_
#define XXX_H_
//...
#endif
```

### 链接（linkage）

把生成的 `.o` 文件（叫什么？）和库之类的拼到一起，输出可执行文件的过程。

注意：不在同一编译器下生成的多个库可能没有办法统一链接。

哪些东西可以跨文件使用？这牵涉到程序内存分配的问题。

#### 作用域（`scope`）

名称在多大范围是可见的，本质上也就是描述该名称所占用的内存在多大范围上是可见的。

主要作用是考察名称在链接的时候如何可见。

#### 某名称放在某个函数里面的时候...：自动存储的连续性

只有 `{...}` 之间能看到；如果出现了重复名称，内层 `{...}` 的名称会占据优势，但是外层的名称在离开内层之后依旧可用。

## 第十三~十四章 类与继承

### 类

类就是用户自定义的类型（`user-defined type`）。`class`，`struct`，`union` 都是类关键字（`class-key`）

声明一个类的方式：`class-key class-head-name;` 

定义一个类的方式：

`class-key [attr] class-head-name [:base-specifier-list] {member-specification};`

类的现实意义，就是建立起了“普遍-个别”的联系，让程序可以表达这样的联系。为了表达普遍性质的联系，需要类的派生与继承。

#### 类的“成员组成”

可以有成员数据（`data member`），成员函数（`member functions`），两者都可以有静态（`static`）与非静态（`non-static`）。

还可以有内含的类型（`nested types`）。如类（`class`）或者枚举体（`enum`）。可以用 `auto` 规避掉私有名称（`private name`）的使用。如 `typedef` 或 `using` 的类型别名。

类的成员声明必须在类的定义中进行。不能补充声明。

类的成员可以具有三种属性：公共（`public`），保护（`protected`），私有（`private`）。公共成员可以任意访问，私有和保护成员则只能被类的成员使用。保护成员在派生类时有不同于私有成员的表现。

有一些特殊的成员函数：缺省/拷贝/移动构造函数（`default/copy/move constructor`），`=` 运算符（拷贝/移动），析构函数（`destructor`）。

类如果有任何一个虚函数（`virtual`），那么这个类的成员将表现出多态性（`polymorphic`）。

### 派生类 derived classes

派生类阐述的是“是个（`is-a`）”关系。

与派生类相对的概念是基类（`base class`）。

基类和派生类之间的关系用"继承"来描述。

根据基类的成员在派生类中被访问的许可，继承分为公有继承和私有继承（和保护继承）。

| 基类中的访问限定<br />在派生类中的地位 | 公有（`public`） | 保护（`protected`） | 私有（`private`） |
| -------------------------------------- | ---------------- | ------------------- | ----------------- |
| 公有继承                               | 公开成员         | 保护成员            | 不可被访问        |
| 保护继承                               | 保护             | 保护                | 不可被访问        |
| 私有继承                               | 私有             | 私有                | 不可被访问        |

所有访问限定都可以通过友元进行忽略。

派生类中可以对基类的成员（数据？函数？）进行重载。

可以用 指向基类对象的指针/引用 指向 某派生类对象（这称为`upcasting`）。当通过该指针/引用使用成员函数时，默认使用基类版本（除了下文所提到的多态性可以使行为与派生类相同）。【这是静态绑定的要求】

### 多态性（`polymorphism`）

多态性指的就是：相同类型的指针/引用可以表现出不同的类型的行为。这些不同的类型应该有派生的相关关系。

采用 `virtual` 关键字声明函数，该函数成为虚函数。虚函数继承后仍有虚属性，即使不显式声明。

通过任何基类的指针/引用 对派生类对象具有虚属性的函数的调用，都会调用在继承树（？多重继承）上距离该对象“本来”的类型最近的版本。

### 多重继承（`multiple inheritance`）

这里说的并不是层次上的“多重”，而是直接从“多个”基类继承。
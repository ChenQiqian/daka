# CS:APP 学习笔记

by cqqqwq

好书，好书

[TOC]

## 2 信息的表示与处理

### 2.1.9 移位运算

C 语言中，左/右移 $k$ 位本质上是左/右移 $k \bmod w$ （$w$ 为数的二进制位数）位。

### 2.2.3 补码编码

$-x_{w-1}2^{w-1} + \sum\limits_{i=0}^{w-2}x_i2^i$

表示范围：$-2^{w-1} \rarr 2^{w-1}-1$

#### 旁注：关于printf打印定长整数

使用宏定义：32位有符号用`PRId32` ，64位无符号用 `PRIu64` ；会展开成对劲的样子。

### 2.2.5 C语言中的有符号数和无符号数

$-2147483648$？不靠谱。$-2147483647-1$？ 更靠谱一点。

### 2.2.6 扩展数字的位表示

补码：最高位复制。如 $10001001 = -109 = 1111111110001001$

### 2.3.2 补码加法

补码加法和无符号加法具有完全相同的位级表示

### 2.3.3 补码的非

`-x = ~x+1`

### 2.3.5 补码乘法

补码乘法和无符号乘法具有完全相同的位级表示

用移位和加法来实现。

### 2.3.7 除以2的幂

补码除法用“算术移位”（补充为 $x^{w-1}$） 

### 2.4.1 二进制小数

$b = \sum\limits_{i=\color\red{-n}}^{m}2^i \times b_i$  无法精确表示 1/3 之类的小数

### 2.4.2 IEEE浮点表示

定义一个小数为 $V = (-1)^s \times M \times 2^E$

组成（从高位到低位）：

1. 符号位（ $1$ 位） ：$s = 0$ 是正，$s=1$ 是负
2. 阶码字段（ $k$ 位）：二进制整数 $e$ ，从 $0$ 到 $2^k-1$ 。给定偏移量： $\text{bias} = 2^{k-1} -1$ 。
3. 小数字段（ $n$ 位）：二进制小数 $0 \leq m \leq 1 - \varepsilon,\varepsilon = 2^{-n}$ 。或者可以当成整数再移位也未尝不可。

类型：

1. 非规格化的：$e = 0$ 。令 $E = 1 - \text{bias}, M = m$ 。
2. 规格化的：$1 \leq e \color\red{<} 2^k-1$ 。令 $E = e - \text{bias},M = 1+m$ 。

3. 无穷大： $e = 2^k-1, m = 0$ 。NaN：$e = 2^k-1,m \neq 0$ 。

一些说明：

1. 非规格化中 $E$ 的设置可以提供较为平缓的向规格化的过渡。
2. 规格化数中 $M$ 的设置提供了一位额外的精度，相当于省略掉了最开始的 $1$ 。
3. 如此设置，浮点数的序和直接当作“整数”的序是相同的。并且 $0$ 也是相同的。
4. 单精度：$1+8+23$ 位；双精度： $1+11+52$ 位。

### 2.4.5 浮点运算

不具有结合律，缺少了很重要的一个群属性。

## 3 程序的机器级表示

本章提供了许多示例和大量的练习，来说明汇编语言和编译器的各个不同方面。精通细节是理解更深和更基本概念的先决条件。有人说：“我理解了一般规则，不愿意劳神去学习细节！”他们实际上是在自欺欺人。花时间研究这些示例，完成练习并对照提供的答案来检查你的答案，是非常关键的。

### 3.2.1 机器级代码

ISA：指令集体系结构，将程序的行为描述成好像每条指令都是按顺序进行的，一条指令结束后，另一条指令才开始。

虚拟内存/虚拟地址：用起来像是一个很大的字节数组，实际上是把多个硬件存储器和操作系统软件组合起来。

汇编代码就是二进制机器代码的文字表示。

x86-64 系统：

1. 程序计数器（PC），`%rip` ，下一条指令在内存中的地址。
2. 整数寄存器，16个64位整数。
3. 条件码寄存器，存储了最近的算术/逻辑运算的一些状态，用于（数据流中的）条件变化
4. 向量寄存器，存放一个或多个整数或浮点数值。

### 3.3 数据格式

| 数据类型 | 汇编代码后缀 | 大小（字节） |
| -------- | ------------ | ------------ |
| 字节     | b            | 1            |
| 词       | w            | 2            |
| 双词     | l            | 4            |
| 四词     | q            | 8            |
| 单精度   | s            | 4            |
| 双精度   | l            | 8            |

### 3.4.0 寄存器

### 3.4.1 操作数指示符号

一些格式来表示想要的数字。（$\text{Imm}$ 是立即数字）

| 格式       | 实际值                   | 名称 |
| ---------- | ------------------------ | ---- |
| `$Imm`     | $\text{Imm}$             |      |
| $r_a$      | $R[r_a]$                 |      |
| (...)      | M[...]                   |      |
| (,$r_i$,s) | M[...+ $R[r_i] \cdot s$] |      |
| Imm(...)   | M[Imm + ...]             |      |

### 3.4.2 数据传送指令

注意，32位指令会把寄存器高32位搞成 0 （作为目的时）

`MOV S D`：同长度的普通传送

`MOVZ S R` ：S 做 0 扩展后传输到 R

`MOVI S R` ：S 做补码扩展后传输到 R 

不能是两个内存地址。

### 3.4.4 压入和弹出栈数据

`pushq S` `popq D`

会自动更改表示栈顶的指针 `%rsp` ，加 8 或者减 8。

### 3.5 算数和逻辑操作

`LEAQ S D` ： “加载有效地址”，等效于 `D = &S` 。用来产生指针或利用寻址来简单算数。D 只能是寄存器

`INC/DEC/NEG/NOT D`：一元运算符，分别是自加/自减/取负/取补。

`ADD/SUB/IMUL/XOR/OR/AND` ：二元运算符